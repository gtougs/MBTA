name: Update MBTA Dashboard

on:
  schedule:
    - cron: '0 * * * *'  # Every hour at minute 0
  workflow_dispatch:  # Allow manual triggers from GitHub UI
  push:
    branches: [ main ]  # Run when you push to main branch

jobs:
  update-dashboard:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Collect MBTA data
      env:
        MBTA_API_KEY: ${{ secrets.MBTA_API_KEY }}
      run: |
        python -c "
        import requests
        import json
        import os
        from datetime import datetime
        from collections import defaultdict
        
        # Get MBTA API key from environment
        api_key = os.getenv('MBTA_API_KEY')
        if not api_key:
            print('Error: MBTA_API_KEY not found in environment')
            exit(1)
        
        # MBTA API endpoints
        base_url = 'https://api-v3.mbta.com'
        headers = {'x-api-key': api_key}
        
        try:
            # Get routes
            routes_response = requests.get(f'{base_url}/routes', headers=headers)
            routes_data = routes_response.json()
            total_routes = len(routes_data.get('data', []))
            
            # Get vehicles
            vehicles_response = requests.get(f'{base_url}/vehicles', headers=headers)
            vehicles_data = vehicles_response.json()
            active_vehicles = len(vehicles_data.get('data', []))
            
            # Get predictions for delay analysis
            predictions_response = requests.get(f'{base_url}/predictions', headers=headers)
            predictions_data = predictions_response.json()
            
            # Analyze delays and problems
            delays = []
            problem_routes = defaultdict(int)
            problem_stops = defaultdict(int)
            
            for pred in predictions_data.get('data', []):
                if 'attributes' in pred:
                    attrs = pred['attributes']
                    if 'departure_time' in attrs and 'arrival_time' in attrs:
                        # Calculate delay
                        scheduled = attrs.get('departure_time') or attrs.get('arrival_time')
                        predicted = attrs.get('departure_time') or attrs.get('arrival_time')
                        
                        if scheduled and predicted:
                            try:
                                scheduled_time = datetime.fromisoformat(scheduled.replace('Z', '+00:00'))
                                predicted_time = datetime.fromisoformat(predicted.replace('Z', '+00:00'))
                                delay_minutes = (predicted_time - scheduled_time).total_seconds() / 60
                                
                                if abs(delay_minutes) > 2:  # More than 2 minutes delay
                                    delays.append(delay_minutes)
                                    
                                    # Track problem routes
                                    if 'relationships' in pred and 'route' in pred['relationships']:
                                        route_id = pred['relationships']['route']['data']['id']
                                        problem_routes[route_id] += 1
                                    
                                    # Track problem stops
                                    if 'relationships' in pred and 'stop' in pred['relationships']:
                                        stop_id = pred['relationships']['stop']['data']['id']
                                        problem_stops[stop_id] += 1
                            except:
                                pass
            
            # Get alerts for service issues
            alerts_response = requests.get(f'{base_url}/alerts', headers=headers)
            alerts_data = alerts_response.json()
            active_alerts = len([a for a in alerts_data.get('data', []) 
                               if a.get('attributes', {}).get('active_period')])
            
            # Compile problem analysis
            problem_analysis = {
                'last_updated': datetime.now().isoformat(),
                'total_routes': total_routes,
                'active_vehicles': active_vehicles,
                'total_predictions': len(predictions_data.get('data', [])),
                'active_alerts': active_alerts,
                'delays': {
                    'total_delays': len(delays),
                    'average_delay_minutes': round(sum(delays) / len(delays), 1) if delays else 0,
                    'max_delay_minutes': round(max(delays), 1) if delays else 0
                },
                'problem_routes': dict(sorted(problem_routes.items(), key=lambda x: x[1], reverse=True)[:10]),
                'problem_stops': dict(sorted(problem_stops.items(), key=lambda x: x[1], reverse=True)[:10]),
                'status': 'active'
            }
            
            # Save to file
            with open('docs/data/latest_stats.json', 'w') as f:
                json.dump(problem_analysis, f, indent=2)
            
            print('Data collected successfully!')
            print(f'Routes: {total_routes}, Vehicles: {active_vehicles}, Delays: {len(delays)}')
            
        except Exception as e:
            print(f'Error collecting data: {e}')
            exit(1)
        "
    
    - name: Commit and push changes
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add docs/data/latest_stats.json
        git commit -m "Update dashboard data [skip ci]" || exit 0
        git pull --rebase origin main
        git push origin main
