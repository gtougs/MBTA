name: Update MBTA Dashboard

on:
  schedule:
    - cron: '0 * * * *'  # Every hour at minute 0
  workflow_dispatch:  # Allow manual triggers from GitHub UI
  push:
    branches: [ main ]  # Run when you push to main branch

permissions:
  contents: write

jobs:
  update-dashboard:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        pip install requests
    
    - name: Collect MBTA data
      env:
        MBTA_API_KEY: ${{ secrets.MBTA_API_KEY }}
      run: |
        python -c "
        import requests
        import json
        import os
        from datetime import datetime, timedelta
        from collections import defaultdict
        
        # Get MBTA API key from environment
        api_key = os.getenv('MBTA_API_KEY')
        if not api_key:
            print('Error: MBTA_API_KEY not found in environment')
            exit(1)
        
        # MBTA API endpoints
        base_url = 'https://api-v3.mbta.com'
        headers = {'x-api-key': api_key}
        
        try:
            print('Collecting detailed MBTA data...')
            
            # Get routes with detailed info
            routes_response = requests.get(f'{base_url}/routes', headers=headers)
            routes_data = routes_response.json()
            total_routes = len(routes_data.get('data', []))
            
            # Get vehicles with real-time locations
            vehicles_response = requests.get(f'{base_url}/vehicles', headers=headers)
            vehicles_data = vehicles_response.json()
            active_vehicles = len(vehicles_data.get('data', []))
            
            # Get predictions for delay analysis
            predictions_response = requests.get(f'{base_url}/predictions', headers=headers)
            predictions_data = predictions_response.json()
            
            # Get alerts for service issues
            alerts_response = requests.get(f'{base_url}/alerts', headers=headers)
            alerts_data = alerts_response.json()
            
            # Analyze delays and problems
            delays = []
            problem_routes = defaultdict(int)
            problem_stops = defaultdict(int)
            vehicle_locations = []
            hourly_vehicle_counts = defaultdict(int)
            route_vehicle_counts = defaultdict(int)
            
            # Process vehicle locations for map and route counts
            for vehicle in vehicles_data.get('data', []):
                if 'attributes' in vehicle and 'latitude' in vehicle['attributes'] and 'longitude' in vehicle['attributes']:
                    lat = vehicle['attributes']['latitude']
                    lng = vehicle['attributes']['longitude']
                    if lat and lng and lat != 0 and lng != 0:
                        route_id = vehicle.get('relationships', {}).get('route', {}).get('data', {}).get('id', 'Unknown')
                        route_vehicle_counts[route_id] += 1
                        
                        vehicle_locations.append({
                            'lat': lat,
                            'lng': lng,
                            'route': route_id,
                            'type': 'vehicle',
                            'vehicle_id': vehicle.get('id', 'Unknown')
                        })
                        
                        # Count vehicles by hour for chart
                        current_hour = datetime.now().hour
                        hourly_vehicle_counts[current_hour] += 1
            
            # Process predictions for delay analysis
            for pred in predictions_data.get('data', []):
                if 'attributes' in pred:
                    attrs = pred['attributes']
                    scheduled_time = attrs.get('departure_time') or attrs.get('arrival_time')
                    predicted_time = attrs.get('departure_time') or attrs.get('arrival_time')
                    
                    if scheduled_time and predicted_time:
                        try:
                            # Parse times and calculate delays
                            scheduled_dt = datetime.fromisoformat(scheduled_time.replace('Z', '+00:00'))
                            predicted_dt = datetime.fromisoformat(predicted_time.replace('Z', '+00:00'))
                            delay_minutes = (predicted_dt - scheduled_dt).total_seconds() / 60
                            
                            if abs(delay_minutes) > 2:  # More than 2 minutes delay
                                delays.append(delay_minutes)
                                
                                # Track problem routes
                                if 'relationships' in pred and 'route' in pred['relationships']:
                                    route_id = pred['relationships']['route']['data']['id']
                                    problem_routes[route_id] += 1
                                
                                # Track problem stops
                                if 'relationships' in pred and 'stop' in pred['relationships']:
                                    stop_id = pred['relationships']['stop']['data']['id']
                                    problem_stops[stop_id] += 1
                        except Exception as e:
                            print(f'Error processing prediction: {e}')
                            continue
            
            # Process alerts for service issues with detailed info
            active_alerts = []
            for alert in alerts_data.get('data', []):
                if 'attributes' in alert:
                    alert_attrs = alert['attributes']
                    if alert_attrs.get('active_period'):
                        # Get affected routes for this alert
                        affected_routes = []
                        if 'informed_entity' in alert:
                            for entity in alert['informed_entity']:
                                if 'route' in entity:
                                    affected_routes.append(entity['route'])
                        
                        active_alerts.append({
                            'id': alert['id'],
                            'title': alert_attrs.get('header', 'Service Alert'),
                            'description': alert_attrs.get('description', ''),
                            'severity': alert_attrs.get('severity', 'unknown'),
                            'affected_routes': affected_routes,
                            'created_at': alert_attrs.get('created_at', ''),
                            'updated_at': alert_attrs.get('updated_at', '')
                        })
            
            # Build hourly vehicle count chart data (fill in missing hours)
            chart_data = []
            for hour in range(24):
                count = hourly_vehicle_counts.get(hour, 0)
                chart_data.append(count)
            
            # Get route details for better labeling
            route_details = {}
            for route in routes_data.get('data', []):
                route_id = route['id']
                route_attrs = route.get('attributes', {})
                route_details[route_id] = {
                    'name': route_attrs.get('long_name', route_id),
                    'short_name': route_attrs.get('short_name', route_id),
                    'type': route_attrs.get('type', 'unknown'),
                    'color': route_attrs.get('color', '#000000'),
                    'text_color': route_attrs.get('text_color', '#FFFFFF')
                }
            
            # Compile comprehensive problem analysis
            problem_analysis = {
                'last_updated': datetime.now().isoformat(),
                'total_routes': total_routes,
                'active_vehicles': active_vehicles,
                'total_predictions': len(predictions_data.get('data', [])),
                'active_alerts': len(active_alerts),
                'delays': {
                    'total_delays': len(delays),
                    'average_delay_minutes': round(sum(delays) / len(delays), 1) if delays else 0,
                    'max_delay_minutes': round(max(delays), 1) if delays else 0,
                    'delay_distribution': {
                        'minor': len([d for d in delays if 2 <= d <= 5]),
                        'moderate': len([d for d in delays if 5 < d <= 15]),
                        'severe': len([d for d in delays if d > 15])
                    }
                },
                'problem_routes': dict(sorted(problem_routes.items(), key=lambda x: x[1], reverse=True)[:10]),
                'problem_stops': dict(sorted(problem_stops.items(), key=lambda x: x[1], reverse=True)[:10]),
                'vehicle_locations': vehicle_locations[:200],  # Limit to 200 for performance
                'hourly_vehicle_counts': chart_data,
                'route_vehicle_counts': dict(route_vehicle_counts),
                'route_details': route_details,
                'service_alerts': active_alerts[:30],  # Limit to 30 most recent
                'status': 'active'
            }
            
            # Save to file
            with open('docs/data/latest_stats.json', 'w') as f:
                json.dump(problem_analysis, f, indent=2)
            
            print('✅ Detailed data collected successfully!')
            print(f'Routes: {total_routes}, Vehicles: {active_vehicles}')
            print(f'Delays: {len(delays)}, Alerts: {len(active_alerts)}')
            print(f'Problem routes: {len(problem_routes)}, Problem stops: {len(problem_stops)}')
            print(f'Route vehicle counts: {len(route_vehicle_counts)}')
            
        except Exception as e:
            print(f'❌ Error collecting data: {e}')
            exit(1)
        "
    
    - name: Commit and push changes
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add docs/data/latest_stats.json
        git commit -m "Update dashboard data [skip ci]" || exit 0
        git push origin main
