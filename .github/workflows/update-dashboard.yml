name: Update MBTA Dashboard

on:
  schedule:
    - cron: '0 * * * *'  # Every hour at minute 0
  workflow_dispatch:  # Allow manual triggers from GitHub UI
  push:
    branches: [ main ]  # Run when you push to main branch

permissions:
  contents: write

jobs:
  update-dashboard:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests
    
    - name: Collect MBTA data
      env:
        MBTA_API_KEY: ${{ secrets.MBTA_API_KEY }}
      run: |
        python -c "
        import requests
        import json
        import os
        from datetime import datetime
        from collections import defaultdict
        
        # Get MBTA API key from environment
        api_key = os.getenv('MBTA_API_KEY')
        if not api_key:
            print('Error: MBTA_API_KEY not found in environment')
            exit(1)
        
        headers = {'x-api-key': api_key}
        base_url = 'https://api-v3.mbta.com'
        
        try:
            # Get routes with detailed information
            print('ÔøΩÔøΩ Fetching routes...')
            routes_response = requests.get(f'{base_url}/routes', headers=headers)
            routes_response.raise_for_status()
            routes_data = routes_response.json()
            print(f'‚úÖ Found {len(routes_data.get(\"data\", []))} routes')
            
            # Get vehicles with positions
            print('üöå Fetching vehicles...')
            vehicles_response = requests.get(f'{base_url}/vehicles', headers=headers)
            vehicles_response.raise_for_status()
            vehicles_data = vehicles_response.json()
            print(f'‚úÖ Found {len(vehicles_data.get(\"data\", []))} vehicles')
            
            # Get service alerts
            print('‚ö†Ô∏è  Fetching service alerts...')
            alerts_response = requests.get(f'{base_url}/alerts', headers=headers)
            alerts_response.raise_for_status()
            alerts_data = alerts_response.json()
            print(f'‚úÖ Found {len(alerts_data.get(\"data\", []))} alerts')
            
            # Get predictions with proper parameters (limit to avoid 400 errors)
            print('‚è∞ Fetching predictions...')
            try:
                predictions_response = requests.get(f'{base_url}/predictions?limit=100', headers=headers)
                predictions_response.raise_for_status()
                predictions_data = predictions_response.json()
                print(f'‚úÖ Found {len(predictions_data.get(\"data\", []))} predictions')
            except requests.exceptions.HTTPError as e:
                print(f'‚ö†Ô∏è  Predictions API error: {e}')
                predictions_data = {'data': []}
            
            # Process routes by type
            routes_by_type = defaultdict(list)
            for route in routes_data.get('data', []):
                route_type = route['attributes'].get('route_type', 'unknown')
                route_id = route['id']
                route_name = route['attributes'].get('long_name', route['attributes'].get('short_name', 'Unknown'))
                
                if route_type == '0':  # Light rail
                    routes_by_type['Light Rail'].append({'id': route_id, 'name': route_name, 'count': 0})
                elif route_type == '1':  # Heavy rail
                    routes_by_type['Heavy Rail'].append({'id': route_id, 'name': route_name, 'count': 0})
                elif route_type == '2':  # Commuter rail
                    routes_by_type['Commuter Rail'].append({'id': route_id, 'name': route_name, 'count': 0})
                elif route_type == '3':  # Bus
                    routes_by_type['Bus'].append({'id': route_id, 'name': route_name, 'count': 0})
                elif route_type == '4':  # Ferry
                    routes_by_type['Ferry'].append({'id': route_id, 'name': route_name, 'count': 0})
            
            # Count vehicles by route
            vehicle_counts = defaultdict(int)
            for vehicle in vehicles_data.get('data', []):
                route_id = vehicle['relationships'].get('route', {}).get('data', {}).get('id')
                if route_id:
                    vehicle_counts[route_id] += 1
            
            # Update route counts
            for route_type, routes in routes_by_type.items():
                for route in routes:
                    route['count'] = vehicle_counts.get(route['id'], 0)
            
            # Process service alerts
            active_alerts = []
            for alert in alerts_data.get('data', []):
                attrs = alert['attributes']
                if attrs.get('active_period'):
                    for period in attrs['active_period']:
                        start = period.get('start')
                        end = period.get('end')
                        now = datetime.utcnow().isoformat() + 'Z'
                        
                        if (not start or start <= now) and (not end or end >= now):
                            active_alerts.append({
                                'id': alert['id'],
                                'title': attrs.get('short_header', 'Service Alert'),
                                'description': attrs.get('description', 'No description available'),
                                'severity': attrs.get('severity', 'unknown'),
                                'route_id': attrs.get('route_id', 'unknown')
                            })
                            break
            
            # Process delays from predictions (if available)
            delays_by_route = defaultdict(list)
            if predictions_data.get('data'):
                for prediction in predictions_data['data']:
                    attrs = prediction['attributes']
                    if attrs.get('delay') and attrs['delay'] > 0:
                        route_id = prediction['relationships'].get('route', {}).get('data', {}).get('id')
                        if route_id:
                            delays_by_route[route_id].append({
                                'delay': attrs['delay'],
                                'stop_id': attrs.get('stop_id'),
                                'direction': attrs.get('direction_id')
                            })
            
            # Create comprehensive data structure
            dashboard_data = {
                'last_updated': datetime.utcnow().isoformat(),
                'total_routes': len(routes_data.get('data', [])),
                'active_vehicles': len(vehicles_data.get('data', [])),
                'status': 'active',
                'routes_by_type': dict(routes_by_type),
                'active_alerts': active_alerts,
                'delays_by_route': dict(delays_by_route),
                'vehicle_positions': [
                    {
                        'id': v['id'],
                        'route_id': v['relationships'].get('route', {}).get('data', {}).get('id'),
                        'route_type': v['attributes'].get('route_type'),
                        'latitude': v['attributes'].get('latitude'),
                        'longitude': v['attributes'].get('longitude'),
                        'bearing': v['attributes'].get('bearing'),
                        'speed': v['attributes'].get('speed'),
                        'status': v['attributes'].get('status')
                    }
                    for v in vehicles_data.get('data', [])
                    if v['attributes'].get('latitude') and v['attributes'].get('longitude')
                ]
            }
            
            # Save to file
            with open('docs/data/latest_data.json', 'w') as f:
                json.dump(dashboard_data, f, indent=2)
            
            print(f'üéâ Successfully collected data:')
            print(f'   ÔøΩÔøΩ {dashboard_data[\"total_routes\"]} routes')
            print(f'   ÔøΩÔøΩ {dashboard_data[\"active_vehicles\"]} vehicles')
            print(f'   ‚ö†Ô∏è  {len(active_alerts)} active alerts')
            print(f'   üìç {len(dashboard_data[\"vehicle_positions\"])} vehicle positions')
            print(f'   ‚è∞ {len(delays_by_route)} routes with delays')
            
        except Exception as e:
            print(f'‚ùå Error collecting data: {str(e)}')
            # Create fallback data with what we have
            fallback_data = {
                'last_updated': datetime.utcnow().isoformat(),
                'total_routes': 0,
                'active_vehicles': 0,
                'status': 'error',
                'routes_by_type': {},
                'active_alerts': [],
                'delays_by_route': {},
                'vehicle_positions': [],
                'error_message': str(e)
            }
            with open('docs/data/latest_data.json', 'w') as f:
                json.dump(fallback_data, f, indent=2)
            print('‚ö†Ô∏è  Created fallback data file')
            exit(1)
        "
    
    - name: Commit and push changes
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add docs/data/latest_data.json
        git commit -m "Update dashboard data [skip ci]" || exit 0
        git pull origin main
        git push origin main
